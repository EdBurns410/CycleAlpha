import { CyclePoint } from './types';

export const HALVING_DATES = [
  new Date('2012-11-28'),
  new Date('2016-07-09'),
  new Date('2020-05-11'),
  new Date('2024-04-20'), // Estimated/Actual
];

// Helper to generate deterministic pseudo-random numbers
const mulberry32 = (a: number) => {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}

// Generate realistic-looking mock price data for cycles
export const generateMockCycleData = (): Record<string, CyclePoint[]> => {
  const data: Record<string, CyclePoint[]> = {};
  const seed = 12345;
  const random = mulberry32(seed);

  const cycleNames = ['2012 Cycle', '2016 Cycle', '2020 Cycle', 'Current Cycle'];
  const startPrices = [12, 650, 8600, 64000];
  
  cycleNames.forEach((name, index) => {
    const points: CyclePoint[] = [];
    const halvingDate = HALVING_DATES[index];
    const startPrice = startPrices[index];
    let currentPrice = startPrice;
    
    // Cycle duration roughly 4 years (1460 days)
    const duration = index === 3 ? 300 : 1460; 
    
    for (let day = 0; day <= duration; day++) {
      // Base trend (log growth)
      const trend = index < 3 
        ? Math.pow(1.0015, day) // Older cycles grew faster
        : Math.pow(1.0005, day); // Newer cycles slower

      // Cycle shape (Sine wave influence for boom/bust)
      const cycleShape = 1 + Math.sin((day / 1460) * Math.PI * 1.5) * 0.5;
      
      // Noise
      const noise = (random() - 0.5) * 0.05;
      
      // Calculate price
      // This is a very rough approximation to create shapes that look like crypto cycles
      let multiplier = 1;
      if (index === 0) multiplier = trend * cycleShape * (1 + day/200); // 2012 crazy growth
      else if (index === 1) multiplier = trend * cycleShape * (1 + day/500);
      else multiplier = trend * cycleShape;

      // Apply noise
      multiplier = multiplier * (1 + noise);
      
      currentPrice = startPrice * multiplier;

      // Create Date object
      const pointDate = new Date(halvingDate);
      pointDate.setDate(pointDate.getDate() + day);

      points.push({
        daysSinceHalving: day,
        priceMultiplier: parseFloat(multiplier.toFixed(4)),
        cycleId: name,
        date: pointDate.toISOString().split('T')[0],
        price: parseFloat(currentPrice.toFixed(2))
      });
    }
    data[name] = points;
  });

  return data;
};

export const MOCK_CYCLE_DATA = generateMockCycleData();

export const DEFAULT_NEWS_SNIPPETS = [
  "SEC delays decision on Bitcoin ETF application citing market manipulation concerns.",
  "Federal Reserve signals interest rate hike to combat sticky inflation.",
  "Major crypto exchange suffers security breach, 5000 BTC stolen.",
  "Bitcoin network hash rate hits all-time high as miners expand.",
  "MicroStrategy acquires additional 12,000 BTC.",
  "China announces new ban on cryptocurrency mining operations.",
  "El Salvador adopts Bitcoin as legal tender.",
  "DeFi TVL crosses $100 billion milestone.",
];

export const DISCLAIMER = `DISCLAIMER: This platform is for EDUCATIONAL AND RESEARCH PURPOSES ONLY. 
The analysis, simulations, and trade templates provided are hypothetical and generated by AI based on historical patterns. 
Past performance is not indicative of future results. Crypto assets are highly volatile and risky. 
Nothing herein constitutes financial advice.`;